\section{Proofs}

\subsection*{Theorem~\ref{thm:nfh.operations}}

\begin{proof}
{\bf Complementation. }
Let $\A$ be an NFH. The NFA $\hat \A$ 
can be complemented with respect to its language over $\hat\Sigma$ to an NFA 
$\overline{\hat{\A}}$. 
Then for every assignment $v:X\rightarrow S$, it holds that $\hat \A$ accepts 
$\zip(v)$ iff $\overline{\hat{\A}}$ does not accept $\zip(v)$.
%
Let $\overline{\alpha}$ be the quantification condition obtained from $\alpha$ 
by 
replacing every $\exists$ with $\forall$ and vice versa. 
We can prove by induction on $\alpha$ that $\overline{\A}$, the NFH 
whose 
underlying NFA is $\overline{\hat{\A}}$, and whose quantification 
condition is 
$\overline{\alpha}$, accepts $\overline {\hlang{\A}}$.
%
The size of $\overline{\A}$ is exponential in $|Q|$, due to the complementation construction for $\hat\A$.

Now, let $\A_1 = 
\tuple{\Sigma,X,Q,Q_0,\delta_1,F_1,\alpha_1}$ and $\A_2= 
\tuple{\Sigma,Y,P,P_0,\delta_2,F_2,\alpha_2}$ be two NFH with $|X|=k$ and 
$|Y|=k'$ variables, respectively.


\bigbreak
\noindent{\bf Union.}
We construct an NFH 
$\A_{\cup} = \tuple{\Sigma,X\cup Y, Q\cup P\cup\{p_1,p_2\},  Q_0\cup P_0, \delta, 
F_1\cup F_2\cup\{p_1,p_2\}, \alpha}$, where $\alpha = \alpha_1\alpha_2$ (that is, we concatenate the two quantification conditions), and where $\delta$ is defined as follows. 

\begin{itemize}
\item For every $$(q_1\xrightarrow {(\sigma_1,\ldots, \sigma_k)} q_2)\in 
\delta_1$$ we set $$(q_1\xrightarrow{(\sigma_1,\ldots, \sigma_k)+t} q_2)\in 
\delta$$ for every $t\in (\Sigma\cup\{\#\})^{k'}$. 

\item
For every $$(q_1\xrightarrow {(\sigma_1,\ldots, \sigma_{k'})} q_2)\in 
\delta_2$$ we set $$(q_1\xrightarrow{t+(\sigma_1,\ldots, \sigma_{k'})} q_2)\in 
\delta$$ for every $t\in (\Sigma\cup\{\#\})^{k}$. 

\item
For every $q\in F_1$, we set 
$$(q\xrightarrow{(\#)^k+t}p_1)\in \delta$$
and
$$(p_1\xrightarrow{(\#)^k+t}p_1)\in \delta$$
for every $t\in (\Sigma\cup\{\#\})^{k'}$.

\item
For every $q\in F_2$, we set 
$$(q\xrightarrow{t+(\#)^{k'}}p_2)\in \delta$$
and
$$(p_2\xrightarrow{t+(\#)^{k'}}p_2)\in \delta$$
for every $t\in (\Sigma\cup\{\#\})^{k}$.
\end{itemize}

Let $S$ be a hyperword. 
For every $v:(X\cup Y)\rightarrow S$, it holds that if $\zip(v|_X)\in\lang{\hat\A_1}$, then $\zip(v)\in\lang{\hat\A_{\cup}}$. Indeed, according to our construction, every word assigned to the $Y$ variables is accepted in the $\A_1$ component of the construction, and so it satisfies both types of quantifiers.
A similar argument holds for $v|_Y$ and $\A_2$.

Also, according to our construction, for every $v:(X\cup Y)\rightarrow S$,  if $\zip(v)\in\lang{\hat\A_{\cup}}$, then either $\zip(v|_X)\in\lang{\hat\A_1}$, or $\zip(v|_Y)\in\lang{\hat\A_2}$. 
%
As a conclusion, we have that $\hlang{\A_{\cup}} = \hlang{\A_1}\cup\hlang{\A_2}$. 

The state space of $\A_\cup$ is linear in the state spaces of $\A_1,\A_2$. 
However, the size of the alphabet of $\A_\cup$ may be exponentially larger than 
that of $\A_1$ and $\A_2$, since we augment each letter with all sequences of 
size $k'$ (in $\A_1$) and $k$ (in $\A_2$).

\stam{
The proof is similar to the standard constructive proof for NFAs. Let $\A = 
\tuple{\Sigma,X,Q,Q_0,\delta,F,\alpha}$ with underlying NFA and $\A'= 
\tuple{\Sigma',X',Q',Q'_0,\delta',F',\alpha'}$ be two NHFs. We now construct an 
NHF $\A'' = \tuple{\Sigma'',X'',Q'',Q''_0,\delta'',F'',\alpha''}$ that accepts 
$\hlang{\A} \cup \hlang{\A'}$ as follows. Let
%
\begin{itemize}
 \item  $\Sigma'' = \Sigma \cup \Sigma' \cup \{\#\}$,
 \item $X'' = X \cup X'$,
 \item $Q'' = Q \cup Q' \cup \{q_{\mathit{init}}\}$, \todo{Sarai: we allow a set 
of inital state, so taking the union is enough, no need for a new state}
 \item $Q''_0 = q_{\mathit{init}}$,
 \item $F'' = F \cup F'$,
 \item $\alpha'' = \alpha.\alpha'$
 
\end{itemize}
%
Transitions of $\A''$ include the following:

\begin{itemize}
 \item  We add transitions $q\xrightarrow{\epsilon} q'$, for each $q' \in 
Q''_0$, where $\epsilon$ is the null letter. 

\item For each transition $q \xrightarrow{(\sigma_{i_1}, \dots, \sigma_{i_k})} 
q' \in \delta$ in the underlying NFA of $\A$, we include a transition $q 
\xrightarrow{(\sigma_{i_1}, \dots, \sigma_{i_k}, \#, \dots, \#)} q'$ in 
$\delta''$, where $\#$ is repeated $|\alpha'|$ number of times (i.e., the 
number 
of quantifiers in $\alpha$). Likewise, for each transition $q 
\xrightarrow{(\sigma_{i_1}, \dots, \sigma_{i_{k'}})} q' \in \delta'$ (in the 
underlying NFA of $\A'$), we include a transition $q \xrightarrow{(\#, \dots, 
\#, \sigma_{i_1}, \dots, \sigma_{i_{k'}})} q'$ in $\delta''$, where $\#$ is 
repeated $|\alpha|$ number of times (the number of quantifiers in $\alpha$).
\todo{Sarai: I think this is incorrect. We should not add $\#$, but every 
possible combination of $\Sigma\cup\{\#\}$ letters}
\end{itemize}

Now, it is straightforward to see that every hyperword in $\hlang{\A}$ or 
$\hlang{\A'}$ is accepted by $\A''$. This is because the quantifiers not 
relevant to hyperwords (e.g., $\alpha$) for a hyperword in $\hlang{\A'}$ are 
taken care of by the padded words in $(\#, \dots, \#, \sigma_{i_1}, \dots, 
\sigma_{i_{k'}})$. The same argument holds for quantifiers in $\alpha'$ and 
hyperwords in $\hlang{\A}$.
}% of stam

\bigbreak
\noindent{\bf Intersection.}
The proof follows the closure under union and complementation. However, we
also offer a direct translation, which avoids the need to complement. 
We construct an NFH 
$\A_\cap = \tuple{\Sigma,X\cup Y, (Q\cup \{q\} \times P\cup \{p\}), (Q_0\times P_0), \delta, 
(F_1\cup\{q\}) \times (F_2\cup\{p\}), \alpha_1\alpha_2}$, where $\delta$ is defined as follows. 
\begin{itemize}
    \item For every $(q_1\xrightarrow {(\sigma_1,\ldots, \sigma_k)} q_2)\in 
\delta_1$ and every $(p_1\xrightarrow {(\sigma'_1,\ldots, \sigma'_{k'}) 
}p_2)\in\delta_2$, we have 
%
$$\Big((q_1,p_1)\xrightarrow{(\sigma_1\ldots, \sigma_k,\sigma'_1,\ldots 
\sigma'_{k'})} (q_2,p_2)\Big)\in\delta$$
%
\item For every $q_1\in F_1, (p_1 \xrightarrow{(\sigma'_1,\ldots, 
\sigma'_{k'})} p_2)\in \delta_2$ we have
%
$$\Big((q_1,p_1)\xrightarrow {(\#)^k +(\sigma'_1,\ldots 
\sigma'_{k'})}(q,p_2)\Big), \Big((q,p_1)\xrightarrow {(\#)^k+(\sigma'_1,\ldots, 
\sigma'_{k'})}(q,p_2)\Big) \in \delta$$
%
\item For every $(q_1\xrightarrow {(\sigma_1,\ldots, \sigma_k)} q_2)\in 
\delta_1$ and $p_1\in F_2$, we have
%
$$\Big((q_1,p_1)\xrightarrow 
{(\sigma_1,\ldots, \sigma_{k})+(\#)^{k'}}(q_2,p)\Big), \Big((q_1,p)\xrightarrow 
{(\sigma_1,\ldots, \sigma'_{k})+(\#)^{k'}}(q_2,p)\Big)\in \delta$$
\end{itemize}
%
Intuitively, the role of $q,p$ is to keep reading $(\#)^k$ and $(\#)^{k'}$ after 
the word read by $\hat\A_1$ or $\hat\A_2$, respectively, has ended. 

The NFH $\hat{\A_\cap}$ simultaneously reads two words $\zip(w_1, w_2, \ldots, 
w_k)$ and $\zip(w'_1,w'_2,\ldots w'_{k'})$ that are read along $\hat\A_1$ and 
$\hat\A_2$, 
respectively, and accepts iff both words are accepted. The correctness 
follows from the fact that for $v:(X\cup Y)\rightarrow S$, we have that 
$\zip(v)$ is accepted by $\hat\A$ iff $\zip (v|_X)$ and $\zip(v|_Y)$ are 
accepted by $\hat\A_1$ and $\hat\A_2$, respectively. 

This construction is polynomial in the sizes of $\A_1$ and $\A_2$.
\end{proof}


\subsection*{Theorem~\ref{thm:nfh.nonemptiness}}

\begin{proof}
We mimic the proof idea in~\cite{fh16}, which uses a reduction from the {\em 
Post correspondence problem (PCP)}.
%
A PCP instance is a collection $C$ of dominoes of the form:
$$ \Bigg\{\Big[\frac{u_1}{v_1} \Big], 
\Big[\frac{u_2}{v_2} \Big],\dots, \Big[\frac{u_k}{v_k} \Big] \Bigg\}$$
where for all $i \in [1, k]$, we have $v_i,u_i \in 
\{a,b\}^*$.
%\alphabet_{\mathit{pcp}}^*$.
%
The problem is to decide whether there exists a finite sequence of the dominoes 
of the form
%
$$\Big[\frac{u_{i_1}}{v_{i_1}} \Big]\Big[\frac{u_{i_2}}{v_{i_2}} \Big] \cdots 
\Big[\frac{u_{i_m}}{v_{i_m}} \Big]$$
%
where each index $i_j \in [1, k]$, such that the upper and lower finite 
strings of the dominoes are equal, i.e.,
%
$$ u_{i_1}u_{i_2}\cdots{}u_{i_m} = v_{i_1}v_{i_2}\cdots{}v_{i_m}$$
%
For example, if the set of dominoes is
%
$$ C_{\mathsf{exmp}} = \Bigg\{ \Big[\frac{ab}{b}\Big], 
\Big[\frac{ba}{a}\Big],\Big[\frac{a}{aba}\Big] \Bigg\} $$
%
Then, a possible solution is the following sequence of dominoes from 
$C_{\mathsf{exmp}}$: 
%
$$\mathsf{sol} = \Big[\frac{a}{aba}\Big]\Big[\frac{ba}{a}\Big] 
\Big[\frac{ab}{b}\Big ].  $$

%
\stam{
For some collection of dominoes, it is impossible to find a match. 
An example is 
the following:
$$\Big[\frac{w}{v} \Big] = \bigg\{\Big[\frac{abc}{ab} \Big], \Big[\frac{ca}{a} 
\Big], \Big[\frac{acc}{ba} \Big]\bigg\}$$

First, we map an arbitrary instance of the PCP 
$[\frac{w}{v}]=\{[\frac{w_2}{v_2}], [\frac{w_2}{v_2}], \dots, 
[\frac{w_k}{v_k}]\}$ to an NHF.
}

Given an instance $C$ of PCP, we encode a solution as a word $w_{sol}$ over the 
following alphabet:
%
$$\alphabet = \Big\{\frac{\sigma}{\sigma'} \mid \sigma,\sigma'\in\{a,b,{\dot 
a},{\dot b}, \$\}\Big\}.$$
%
Intuitively, $\dot{\sigma}$ marks the beginning of a new domino, and 
$\$$ marks the end of a sequence of the upper or lower parts of the dominoes 
sequence.

%For a word $w = \frac{\sigma_1}{\sigma'_1}   \frac{\sigma_2}{\sigma'_2}  
% \cdots  \frac{\sigma_n}{\sigma'_n} \in \Sigma^* $, we call $\sigma_1\cdots 
% \sigma_n$ the {\em upper part} of $w$, and the word $\sigma'_1\cdots 
%\sigma'_n$ the {\em lower part} of $w$. 

We note that $w_{sol}$ encodes a legal solution iff the following conditions are 
met:

\begin{enumerate}
    \item For every $ \frac{\sigma}{\sigma'}  $ that occurs in $w_{sol}$, it 
holds that $\sigma,\sigma'$ represent the same domino letter (both $a$ or both 
$b$, either dotted or undotted).
    \item The number of dotted letters in the upper part of $w_{sol}$ is equal 
to the number of dotted letters in the lower part of $w_{sol}$.
    \item $w_{sol}$ starts with two dotted letters, and the word $u_i$ between 
the $i$'th and $i+1$'th dotted letters in the upper part of $w_{sol}$, and the 
word $v_i$ between the corresponding dotted letters in the lower part of 
$w_{sol}$ are such that $ [\frac{u_i}{v_i}]  \in C$, for every $i$.
\end{enumerate}

We call a word that represents the removal of the first $k$ dominoes from 
$w_{sol}$ 
a {\em partial solution}, denoted by $w_{sol,k}$.
Note that the upper and lower parts of $w_{sol,k}$ are not necessarily of equal 
lengths (in terms of $a$ and $b$ sequences), since the upper and lower parts of 
a domino may be of different lengths, and so we use letter $\$$ to pad 
the end of the encoding in the shorter of the two parts. 

We construct an NFH $\A$, which, intuitively, expresses the following ideas: 
$(1)$ There exists an encoding $w_{sol}$ of a solution to $C$, and $(2)$ For 
every $w_{sol,k}\neq \epsilon$ in a hyperword $S$ accepted by $\A$, the word 
$w_{sol,k+1}$ is also in $S$. 

$\hlang{\A}$ is then the set of all hyperwords that contain an encoded solution 
$w_{sol}$, as well as all its suffixes obtained by removing a prefix of dominoes 
from $w_{sol}$. This ensures that $w_{sol}$ indeed encodes a legal solution. For example, a matching hyperword $S$ (for solution 
$\mathsf{sol}$ discussed earlier) that is accepted by $\A$ is:
%
$$ S = \{  w_{sol} = \frac{\dot a}{\dot a}   \frac{\dot b}{b}   \frac{a}{a}   
\frac{\dot a}{\dot a}   \frac{b}{\dot b} ,
w_{sol,1} = \frac{\dot b}{\dot a}\frac{a}{\dot b}\frac{\dot a}{\$}\frac{b}{\$}, 
w_{sol,2} = \frac{\dot a}{\dot b}\frac{b}{\$}, w_{sol,3} = \epsilon
\} $$

Thus, the acceptance condition of $\A$ is $\alpha = \forall x_1\exists x_2 
\exists x_3$, where $x_1$ is to be assigned a potential partial solution 
$w_{sol,k}$, and $x_2$ is to be assigned $w_{sol,k+1}$, and $x_3$ is to be 
assigned $w_{sol}$.  

During a run on a hyperword $S$ and an assignment $v:\{x_1,x_2,x_3\}\rightarrow 
S$, the NFH $\A$ checks that the upper and lower letters of $w_{sol}$ all match.
In addition, $\A$ checks that the first domino of $v(x_1)$ is indeed in $C$, and 
that $v(x_2)$ is obtained from $v(x_1)$ by removing the first tile. 
$\A$ performs the latter task by checking that the upper and lower parts of 
$v(x_2)$ are the upper and lower parts of $v(x_1)$ that have been ``shifted'' 
back appropriately. That is, if the first tile in $v(x_2)$ is the encoding of 
$[\frac{w_i}{v_i}]$, then $\A$ uses states to remember, at each point, the last 
$|w_i|$ letters of the upper part of $v(x_2)$ and the last $|v_i|$ letters of 
the lower part of $v(x_2)$, and verifies, at each point, that the next letter in 
$v(x_1)$ matches the matching letter remembered by the state.
\end{proof}


\subsection*{Theorem~\ref{thm:nfhe.nfhf.nonemptiness}}

\begin{proof}
The lower bound for both fragments follows from the \comp{NL-hardness} of the nonemptiness problem for NFA. 

We turn to the upper bound, and begin with $\nfhe$. Let $\A_\exists$ be an $\nfhe$. 
We claim that $\A_\exists$ is nonempty iff $\hat\A_\exists$ accepts some legal 
word ${\bi w}$. The first direction is trivial. For the second direction, let 
${\bi w}\in\lang{\hat\A_\exists}$, and let $S=\unzip({\bi w})$. By 
assigning $v(x_i) = {\bi w}[i]$ for every $x_i\in X$, we get $\zip(v) = {\bi w}$, and 
according to the semantics of $\exists$, we have that $\A_\exists$ accepts $S$. 
To check whether $\hat\A_\exists$ accepts a legal word, we can run a 
reachability check on-the-fly, while advancing from a letter $\sigma$ to the 
next letter $\sigma'$ only if $\sigma'$ contains $\#$ in all the positions in 
which $\sigma$ contains $\#$. 
While each transition $T = q\xrightarrow{(\sigma_1,\ldots \sigma_n)} p$ in 
$\hat\A$ is of size $k$, we can encode $T$ as a set of size $k$ of encodings of 
transitions of type $q \xrightarrow {\sigma_i} p$ with a binary encoding of 
$p,q,\sigma_i$, as well as $i,t$, where $t$ marks the index of $T$ within the 
set of transitions of $\hat\A$. 
Therefore, the reachability test can be performed within space that is logarithmic in the size of $\A_\exists$.

Now, let $\A_\forall$ be an $\nfhf$ over $X$. We claim that $\A_\forall$ is 
nonempty iff $\A_\forall$ accepts a hyperword of size $1$. 
For the first direction, let $S\in\hlang{\A_\forall}$. Then, by the semantics of 
$\forall$, we have that for every assignment $v:X\rightarrow S$, it holds that 
$\zip(v)\in\lang{\hat{\A_\forall}}$. Let $u\in S$, and let $v_u(x_i) = u$ for every 
$x_i\in X$. Then, in particular, $\zip(v_u)\in\lang{\hat{\A_\forall}}$. Then for every assignment $v:X\rightarrow \{u\}$ (which consists of the 
single assignment $v_u$), it holds that $\hat{\A_\forall}$ accepts $\zip(v)$, 
and therefore $\A_\forall$ accepts $\{u\}$. 
The second direction is trivial. 

To check whether $\A_\forall$ accepts a hyperword of size $1$, we restrict the reachability test on $\hat\A_\forall$ to  
$k$-tuples of the form $(\sigma,\sigma,\ldots \sigma)$ for $\sigma\in \Sigma$. 
\end{proof}

\subsection*{Theorem~\ref{thm:nfhef.nonemptiness}}

\begin{proof}
We begin with the upper bound.
Let $S\in\hlang{\A}$. Then, according to the semantics of the quantifiers, 
there exist $w_1,\ldots w_m \in S$, such that for every assignment 
$v:X\rightarrow S$ in which $v(x_i) = w_i$ for every $1\leq i\leq 
m$, it holds that $\hat\A$ accepts $\zip(v)$. Let $v:X\rightarrow S$ be such an 
assignment. Then, $\hat\A$ accepts 
$\zip(v_\zeta)$ for every sequence $\zeta$ of the form $(1,2,\ldots 
m,i_1,i_2,\ldots i_{k-m})$. 
In particular, it holds for such sequences in which 
$1\leq i_j\leq m$ for every $1\leq j \leq k-m$,
that is, sequences in which the last $k-m$ variables are assigned words that are assigned to the first $m$ variables. Therefore, again 
by the semantics of the quantifiers, we have that $\{v(x_1),\ldots v(x_m)\}$ is 
in $\hlang{\A}$. The second direction is trivial.

We call $\zip(v_\zeta)$ as described above a {\em witness to the nonemptiness of 
$\A$}, i.e., $\zip(v_\zeta)$ is an instantiation of the existential quantifiers.
%
We construct an NFA $A$ based on $\hat\A$ that is nonempty iff $\hat\A$ accepts 
a witness to the nonemptiness of $\A$.
Let $\Gamma$ be the set of all sequences of the above form.
For every sequence $\zeta = (i_1,i_2,\ldots i_k)$ in $\Gamma$, we construct 
an NFA $A_\zeta = \tuple{ \hat\Sigma,Q,Q_0,\delta_\zeta,F}$, where for every 
$q\xrightarrow{(\sigma_{i_1},\sigma_{i_2},\ldots \sigma_{i_k})} q'$ in 
$\delta$, 
we have $q\xrightarrow{(\sigma_1,\sigma_2,\ldots \sigma_k)} q'$ in 
$\delta_\zeta$.
Intuitively, $A_{\zeta}$ runs on every word ${\bi w}$ the same way that $\hat\A$ runs 
on ${\bi w}_\zeta$. Therefore, $\hat\A$ accepts a witness ${\bi w}$ to the nonemptiness of 
$\A$ iff ${\bi w}\in\lang{A_\zeta}$ for every $\zeta\in\Gamma$. 

We define $A = \bigcap_{\zeta\in\Gamma} A_\zeta$.
Then $\hat\A$ accepts a witness to the nonemptiness of $\A$ iff $A$ is 
nonempty. 
Since $|\Gamma| = m^{k-m}$, the state space of $A$ is of size $O(n^{m^{k-m}})$, where $n=|Q|$, 
and its alphabet is of size $|\hat\Sigma|$. 
%
Notice that for $\A$ to be nonempty, $\delta$ must be of size at least 
$|(\Sigma\cup {\#})|^{(k-m)}$, to account for all the permutations of letters in 
the words assigned to the variables under $\forall$ quantifiers (otherwise, we 
can immediately return ``empty''). Therefore, $|\hat\A|$ is $O(n\cdot 
|\Sigma|^k)$. 
We then have that the size of $A$ is $O(|\hat \A|^k)$.  
%
If the number $k-m$ of $\forall$ quantifiers is fixed, then $m^{k-m}$ is 
polynomial in $k$. However, now $|\hat\A|$ may be polynomial in $n,k$, and $|\Sigma|$, 
and so in this case as well, the size of $A$ is $O(|\hat A|^k)$. 

Since the nonemptiness problem for NFA is \comp{NL-complete}, the problem for $\nfhef$ 
can be decided in space of size that is polynomial in $|{\hat\A}|$. 

\bigbreak
\noindent{\bf \comp{PSPACE hardness}}
For the lower bound, we show a reduction from a polynomial version of the {\em 
corridor tiling problem}, %~\cite{Boas97}, 
defined as follows.
We are given a finite set $T$ of tiles, two relations $V \subseteq T \times T$ 
and $H \subseteq T \times T$,
an initial tile $t_0$, a final tile $t_f$, and a bound $n>0$.
We have to decide whether there is some $m>0$ and a tiling of a $n \times 
m$-grid such that
(1) The tile $t_0$ is in the bottom left corner and the tile $t_f$ is in the top 
right corner,
(2) A horizontal condition: every pair of horizontal neighbors is in $H$, and
(3) A vertical condition: every pair of vertical neighbors is in $V$.
%
When $n$ is given in unary notation, the problem is known to be 
\comp{PSPACE-complete}.

Given an instance $C$ of the tiling problem, we construct an $\nfhef$ $\A$ that 
is nonempty iff $C$ has a solution. 
We encode a solution to $C$ as a word $w_{sol} =w_1\cdot w_2\cdot w_m\$$ over 
$\Sigma = T\cup\{1,2,\ldots n,\$\}$, where the word $w_i$, of the form $1\cdot t_{1,i}\cdot 2 \cdot t_{2,i},\ldots n\cdot 
t_{n,i}$, describes the contents of row $i$. 

To check that $w_{sol}$ indeed encodes a solution, we need to make sure that:
\begin{enumerate}
\item $w_1$ begins with $t_0$ and $w_m$ ends with $t_f\$$.
\item $w_i$ is of the correct form.
\item Within every $w_i$, it holds that $(t_{j,i},t_{j+1,i})\in H$.
    
    \item For $w_i,w_{i+1}$, it holds that $(t_{j,i}, t_{j,i+1})\in V$ for every 
$1\leq j\leq n$.
\end{enumerate} 

Verifying items $1-3$ is easy via an NFA of size $O(n|H|)$.  
The main obstacle is item $4$. 

We describe an $\nfhef$ $\A = \tuple{T\cup \{0,1,2,\ldots n,\$\}, 
\{y_1,y_2,y_3,x_1,\ldots x_{\log(n)}\}, Q, \{q_0\},\delta, F, \alpha}$ that is 
nonempty iff there exists a word that satisfies items $1-4$.
The quantification condition $\alpha$ is $\exists y_1\exists y_2 \exists y_3\forall 
x_1 \ldots \forall x_{\log(n)}$.
The NFH $\A$ only proceeds on letters whose first three positions are of the type 
$(r,0,1)$, where $r\in T\cup\{1,\ldots n,\$\}$. Notice that this means that $\A$
requires the existence of the words $0^{|w_{sol}|}$ and $1^{|w_{sol}|}$ (the $0$ 
word and $1$ word, henceforth).
$\A$ makes sure that the word assigned to $y_1$ matches a correct solution 
w.r.t. items $1-3$ described above.  
We proceed to describe how to handle the requirement for $V$. 
We need to make sure that for every position $j$ in a row, the tile in position 
$j$ in the next row matches the current one w.r.t. $V$. We can use a state $q_j$ 
to remember the tile in position $j$, and compare it to the tile in the next 
occurrence of $j$. The problem is avoiding having to check all positions 
simultaneously, which would require exponentially many states. To this end, we 
use $\log(n)$ copies of the $0$ and $1$ words to form a binary encoding of the 
position $j$ that is to be remembered. The $\log(n)$ $\forall$ conditions make 
sure that every position within $1-n$ is checked.  

We limit the checks to words in which $x_1,\ldots x_{\log(n)}$ are the $0$ or 
$1$ words, by having $\hat\A$ accept every word in which there is a letter that 
is not over $0,1$ in positions $4,\ldots \log(n)+3$. This takes care 
of accepting all cases in which the word assigned to $y_1$ is also assigned to 
one of the $x$ variables. 

To check that $x_1,\ldots x_{\log(n)}$ are the $0$ or $1$ words, $\hat\A$ checks 
that the values in positions $4$ to $\log(n)+3$ remain constant throughout the 
run. 
In these cases, upon reading the first letter, $\hat\A$ remembers the value $j$ 
that is encoded by the constant assignments to $x_1,\ldots x_{\log(n)}$ in a 
state, and makes sure that throughout the run, the tile that occurs in the 
assignment $y_1$ in position $j$ in the current row matches the tile in position 
$j$ in the next row. 

We construct a similar reduction for the case that the number of $\forall$ 
quantifiers is fixed: instead of encoding the position by $\log(n)$ bits, we can 
directly specify the position by a word of the form $j^*$, for every $1\leq 
j\leq n$. 
Accordingly, we construct an $\nfhef$ over $\{x, y_1,\ldots y_{n},z\}$, with a 
quantification condition $\alpha = \exists x\exists y_1 \ldots \exists 
y_{n}\forall z$. The NFA $\hat\A$ advances only on letters whose assignments to 
$y_1,\ldots y_n$ are always $1,2,\ldots n$, respectively, and checks only words 
assigned to $z$ that are some constant $1\leq j\leq n$. Notice that the fixed 
assignments to the $y$ variables leads to $\delta$ of polynomial size.  
In a hyperword accepted by $\A$, the word assigned to $x$ is $w_{sol}$, and the 
word assigned to $z$ specifies which index should be checked for conforming to 
$V$.
\end{proof}



\subsection*{Theorem~\ref{thm:nfh.membership.finite}}

\begin{proof}
We can decide the membership of $S$ in $\hlang{\A}$ by iterating over all relevant assignments from $X$ to $S$, and for every such assignment $v$, checking on-the-fly whether $\zip(v)$ is accepted by $\hat\A$. 
This algorithm uses space of size that is polynomial in $k$ and logarithmic in $|\A|$ and in $|S|$. 

In the case that $k' = O(\log k)$, an \comp{NP} upper bound is met by iterating over 
all assignments to the variables under $\forall$, while guessing assignments to 
the variables under $\exists$. For each such assignment $v$, checking whether $\zip(v)\in\lang{\hat\A}$ can be done on-the-fly. 

We show \comp{NP-hardness} for this case by a reduction from the Hamiltonian cycle problem. 
Given a graph $G = \tuple{V,E}$ where $V = \{v_1,v_2,\ldots, v_n\}$ and 
$|E|=m$, 
we construct an $\nfhe$ $\A$ over $\{0,1\}$ with $n$ states, $n$ variables, 
$\delta$ of size $m$, and a hyperword $S$ of size $n$, as follows. $S = 
\{w_1,\ldots, w_n\}$, where $w_i$ is the word over $\{0,1\}$ in which all 
letters 
are $0$ except for the $i$'th. 
The structure of $\hat\A$ is identical to that of $G$, and we set $Q_0 = F = 
\{v_1\}$. For the transition relation, for every $(v_i,v_j)\in E$, we have 
$(v_i, \sigma_i,v_j)\in \delta$, where $\sigma_i$ is the letter over $\{0,1\}^n$ 
in which all positions are $0$ except for position $i$. 
Intuitively, the $i$'th letter in an accepting run of $\hat\A$ marks traversing 
$v_i$. Assigning $w_j$ to $x_i$ means that the $j$'th step of the run 
traverses $v_i$. Since the words in $w$ make sure that every $v\in V$ is 
traversed exactly once, and that the run on them is of length $n$, we have that 
$\A$ accepts $S$ iff there exists some permutation $p$ of the words in $S$ such 
that $p$ matches a Hamiltonian cycle in $G$.

\noindent{\it remark}
To account for all the assignments to the $\forall$ variables, $\delta$ -- and therefore, $\hat\A$ -- must be of size at least $2^{k'}$ (otherwise, we can return ``no'').
We then have that if $k = O(k')$, then space of size $k$ is logarithmic in $|\hat\A|$, and so the problem in this case can be solved within logarithmic space.
A matching NL lower bound follows from the membership problem for NFA. 
\end{proof}


\subsection*{Theorem~\ref{thrm:membershipFULL}}

\begin{proof}
Let $A = \tuple{\Sigma, P, P_0, \rho,F}$ be an NFA, and let $\A = \tuple{\Sigma, 
\{x_1,\ldots, x_k\}, Q, Q_0, \delta, {\cal F},\alpha}$ be an NFH. 

First, we construct an NFA $A'=\tuple{\Sigma\cup\{\#\}, P', P'_0, \rho', F'}$
by extending the alphabet of $A$ to $\Sigma\cup\{\#\}$, adding a new and 
accepting state $p_f$ to $P$ with a self-loop labeled by $\#$, and transitions 
labeled by $\#$ from every $q\in F$ to $p_f$. 
The language of $A'$ is then $\lang{A}\cdot \#^*$.  
We describe a recursive procedure (iterating over $\alpha$) for deciding 
whether $\lang{A}\in\hlang{\A}$.

For the case that $k=1$, it is easy to see that if $\alpha = \exists x_1$, then 
$\lang{A}\in\hlang{\A}$ iff $\lang{A}\cap \lang{\hat{\A}} \neq \emptyset$.
Otherwise, if $\alpha = \forall x_1$, then $\lang{A}\in\hlang{\A}$ iff 
$\lang{A}\notin \hlang{\overline{\A}}$, where $\overline{\A}$ is the NFH for 
$\overline{\hlang{\A}}$ described in Theorem~\ref{thm:nfh.operations}. 
Notice that the quantification condition for $\overline{\A}$
is $\exists x_1$, and so this conforms to the base case.

For $k>1$, we construct a sequence of NFH $\A_1, \A_2, \ldots, \A_k$. 
If $\quant_1 = \exists$ then we set $\A_1 = \A$, and otherwise we set $\A_1 = \overline{\A}$.
Let $\A_i = \tuple{\Sigma, \{x_i,\ldots, x_k\}, Q_i, 
Q^0_i, \delta_i, {\cal F}_i,\alpha_i}$.
If $\alpha_i$ starts with $\exists$, then 
we construct $\A_{i+1}$ as follows. 

The set of variables of $\A_{i+1}$ is $\{x_{i+1},\ldots, x_k\}$, and the 
quantification condition $\alpha_{i+1}$ is \linebreak $\quant_{i+1}x_{i+1}\cdots 
\quant_kx_k$, for $\alpha_i = \quant_ix_i \quant_{i+1}\cdots \quant_kx_k$. 
The set of states of $\A_{i+1}$ is $ Q_i\times P'$, and the set of initial 
states is $Q_i^0\times P_0$. The set of accepting states is ${\cal F}_i\times 
F'$.
For every 
$(q\xrightarrow{(\sigma_i,\ldots,\sigma_k)}q')\in\delta_i$ and every 
$(p\xrightarrow{\sigma_i}p')\in \rho$, we have 
$((q,p)\xrightarrow{(\sigma_{i+1},\ldots, \sigma_k)}(q',p'))\in\delta_{i+1}$. 
Then, $\hat\A_{i+1}$ accepts a word $\zip(u_1,u_2,\ldots, u_{k-i})$ iff there 
exists a word $u\in \lang{A}$, such that $\hat\A_{i}$ accepts 
$\zip(u,u_1,u_2,\ldots, u_{k-i})$. 

 Let $v:\{x_{i},\ldots, x_k\}\rightarrow \lang{A}$.
Then $\lang{A}\models _v (\alpha_i,\A_i)$ iff there exists $w\in \lang{A}$ such 
that $\lang{A}\models_{v[x_i\rightarrow w]} (\alpha_{i+1},\A_i)$.
For an assignment $v':\{x_{i+1},\ldots, x_k\}\rightarrow \lang{A}$, it holds 
that 
$\zip(v')$ is accepted by $\hat{\A}_{i+1}$ iff there exists a word $w\in 
\lang{A}$ such that $\zip(v)\in\lang{\hat{\A}_i}$, where $v$ is obtained from 
$v'$ 
by setting $v(x_i) = w$. 
Therefore, we have that $\lang{A}\models_{v[x_i\rightarrow 
w]}(\alpha_{i},\A_i)$ 
iff $\lang{A}\models_{v'} (\alpha_{i+1}, \A_{i+1})$, that is, 
$\lang{A}\in\hlang{\A_i}$ iff $\lang{A}\in\hlang{\A_{i+1}}$. 


If $\alpha_i$ starts with $\forall$, then we have that $\lang{A}\in \hlang{\A_i}$ iff 
$\lang{A}\notin \overline{\hlang{\A_i}}$. We construct $\overline{\A_{i}}$ for 
$\overline{\hlang{\A_i}}$ as described in Theorem~\ref{thm:nfh.operations}. The 
quantification condition of $\overline{\A_{i}}$ then begins with $\exists x_i$, and we 
apply the previous case, and construct $\A_{i+1}$ w.r.t. $\overline{\A_{i}}$, to check 
for non-membership.

Every $\forall$ quantifier requires complementation, which is exponential in 
$n$, the number of states in $\A$. Therefore, in the worst case, the complexity of this algorithm is 
$O(2^{2^{...^{|Q||A|}}})$, where the tower is of height $k$. If the number of 
$\forall$ quantifiers is fixed, then the complexity is $O(|Q||A|^k)$. 
\end{proof}


\subsection*{Theorem~\ref{thrm:containment}}


\begin{proof}
For the lower bound, we show a reduction from the containment problem for NFA, which is known to be \comp{PSPACE-hard}.
Let $A_1,A_2$ be NFA. We ``convert'' them to NFH $\A_1,\A_2$ by adding to both a single variable $x$, and a quantification condition $\forall x$.
By the semantics of the $\forall$ quantifier, we have that $\hlang{\A_1} = \{S | S\subseteq \lang{A_1}\}$, and similarly for $\A_2$. 
Therefore, we have that $\hlang{\A_1}\subseteq \hlang{\A_2}$ iff $\lang{A_1}\subseteq \lang{A_2}$.

For the upper bound, first notice that complementing an $\nfhf$ yields an 
$\nfhe$, and vice versa. 
Consider two NFH $\A_1$ and $\A_2$.
%, where $\A_1,\A_2\in\nfhf,\nfhe$. 
Then $\hlang{\A_1}\subseteq\hlang{\A_2}$ iff 
$\hlang{\A_1}\cap\overline{\hlang{\A_2}}  =  \emptyset$. 
We can use the constructions in the proof of Theorem~\ref{thm:nfh.operations} 
to compute a matching NFH $\A = 
\A_1\cap\overline{\A_2}$, and check its nonemptiness.
The complementation construction is exponential in $n_2$, the number of states 
of $\A_2$, and the intersection construction is polynomial in $|\A_1|, 
|\overline{\A_2}|$. 

If $\A_1\in\nfhe$ and $\A_2\in\nfhf$ or vice versa, then $\A$ is an $\nfhe$ or 
$\nfhf$, respectively, whose nonemptiness can be decided in space that is 
logarithmic in $|\A|$. 

Now, consider the case where $\A_1$ and $\A_2$ are both $\nfhe$ or both $\nfhf$.
It follows from the proof of Theorem~\ref{thm:nfh.operations}, that for two 
NFH $\A,\A'$, the quantification condition of $\A\cap\A'$ may be any 
interleaving of the quantification conditions of $\A$ and $\A'$. Therefore, if 
$\A_1,\A_2\in\nfhe$ or $\A_1,\A_2\in\nfhf$, we can construct $\A$ to be an 
$\nfhef$. 
This is also the case when $\A_1\in\nfhef$ and $\A_2\in\nfhe$ or $\A_2\in\nfhf$.

Either $\A_2$ or $\overline{\A_2}$ is an $\nfhf$, whose underlying NFA has a transition relation of size that is exponential in $k$ (otherwise the $\nfhf$ is empty). The same holds for $\A_1\in\nfhef$. The PSPACE upper bound of Theorem~\ref{thm:nfhef.nonemptiness} is derived from the number of variables and not from the state-space of the NFH. Therefore, while $|\bar{\A_2}|$ is exponential in the number of states of $\A_2$, checking the nonemptiness of $\A$ is in \comp{PSPACE}. 
\end{proof}


\subsection*{Lemma~\ref{lem:langeq}}

\begin{proof}
We begin with $\nfhf$.
For the first direction, since $\lang{\hat\A_\forall'}\subseteq \lang{\hat\A_\forall}$, we have 
$\hlang{\A_\forall'}\subseteq \hlang{\A_\forall}$.
For the second direction, let 
$S\in\hlang{A_\forall}$. Then for every $v:S\rightarrow X$, it holds that 
$\zip(v)\in\lang{\hat\A_\forall}$. Also,   $\zip(v')\in\lang{\hat\A_\forall}$ for every sequence 
$v'$ of $v$. Then $\zip(v)$ and all its sequences are in $\lang{\hat\A_\forall'}$. Since 
this holds for every $v:X\rightarrow S$, we have that $S\in\hlang{\A_\forall'}$.

We proceed to $\nfhe$.
For the first direction, since $\lang{\hat\A_\exists}\subseteq \lang{\hat\A_\exists'}$, we have 
$\hlang{\A}\subseteq \hlang{\A'}$.
For the second direction, let 
$S\in\hlang{A_\exists'}$. Then there exists $v:S\rightarrow X$ such that 
$\zip(v)\in\lang{\hat\A_\exists'}$. Then
$\zip(v)$ is a permutation of some word $\zip(v')\in\lang{\hat\A_\exists}$.  
According to the semantics of the $\exists$ quantifier, we have that $S\in \hlang{\A_\exists}$.
\end{proof}


\subsection*{Lemma~\ref{lem:permutation.sequence.complete}}

\begin{proof}
We begin with $\nfhf$.
To construct $\A_\forall'$ given $\A_\forall$, we use a similar construction to the one 
presented in the proof of Theorem~\ref{thm:nfhef.nonemptiness}. Essentially, for 
every sequence $\zeta$ of $(1,2,\ldots, k)$, we construct an NFA $A_\zeta$, in 
which every run on a word ${\bi w}$ matches a run of $\hat\A_\forall$ on ${\bi w}_\zeta$. 
The $\nfhf$ $\A'$ is then obtained from $\A_\forall$ by replacing the underlying NFA 
with $\bigcap_{\zeta\in\Gamma} A_\zeta$, where $\Gamma$ is the set of sequences 
of $(1,2,\ldots, k)$.

For $\nfhe$, similarly to the case of $\nfhf$, we construct $\A_\exists'$ given $\A_\exists$ by constructing 
$A_\zeta$ for every permutation $\zeta$ of $(1,2,\ldots, k)$.
In this case, the $\nfhe$ $\A_\exists'$ is obtained from $\A_\exists$ by replacing the 
underlying NFA with $\bigcup_{\zeta\in\Gamma} A_\zeta$, where $\Gamma$ is the 
set of permutations of $(1,2,\ldots, k)$.
\end{proof}

\subsection*{Theorem~\ref{thm:permutation.sequence.complete}}

\begin{proof}
We begin with $\nfhf$.
For the first direction, let ${\bi w}\in\lang{\hat\A_\forall}$.
Since $\A_1$ is sequence-complete, then ${\bi w}'\in\lang{\hat\A_1}$ for every 
sequence ${\bi w}'$ of ${\bi w}$. Then, by the semantics of the $\forall$ quantifier, we 
have that $\unzip({\bi w})\in\hlang{\A_1}$. Therefore, $\unzip({\bi w})\in\hlang{\A_2}$, and so 
${\bi w}$ (and all its sequences) are in $\lang{\hat\A_2}$. A similar argument can be 
made to show that for every ${\bi w}\in\lang{\hat{\A_2}}$, it holds that 
${\bi w}\in\lang{\hat\A_1}$. Therefore, $\lang{\hat\A_1} = \lang{\hat \A_2}$.
The second direction is trivial.


We continue to $\nfhe$.
For the first direction, let ${\bi w}\in\lang{\hat\A_1}$. Then 
$\unzip({\bi w})\in\lang{\A_1}$. 
Then, by the semantics of the $\exists$ quantifier, there exists some 
permutation ${\bi w}'$ of ${\bi w}$ such that ${\bi w}'\in\lang{\hat\A_2}$.
Since $\A_2$ is permutation-complete, we have that ${\bi w}\in\lang{\hat\A_2}$. A 
similar argument can be made to show that for every ${\bi w}\in\lang{\hat{\A_2}}$, it 
holds that ${\bi w}\in\lang{\hat\A_1}$. Therefore, $\lang{\hat\A_1} = \lang{\hat 
\A_2}$.
The second direction is trivial.
\end{proof}


