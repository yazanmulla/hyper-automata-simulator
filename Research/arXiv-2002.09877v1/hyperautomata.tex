\section{Hyperautomata}
\label{sec:ha}

%\subsection{The General Idea}

Before defining hyperautomata, we explain the idea behind them. We first define hyperwords and hyperlanguages.

\begin{definition}
\label{def:hword}
A {\em hyperword over $\Sigma$} is a set of words over $\Sigma$ and a 
{\em hyperlanguage} is a set of hyperwords.
\end{definition}


A 
hyperautomaton $\A$ uses a set of {\em word variables} $X  =\{x_1,x_2,\ldots, x_k\}$. 
When running on a hyperword $S$, these variables are assigned words from $S$. We 
represent an assignment $v:X\rightarrow S$ as the $k$-tuple 
$(v(x_1),v(x_2),\ldots, v(x_k))$. Notice that the variables themselves do not 
appear in this representation of $v$, and are manifested in the order of the 
words in the $k$-tuple: the $i$'th word is the one assigned to $x_i$. This 
allows a cleaner representation with less notations. 

The hyperautomaton $\A$ consists of a {\em quantification condition} $\alpha$ 
over $X$, and an {\em underlying word automaton} $\hat\A$, which runs on words 
that represent assignments to $X$ (we explain how we represent assignments as 
words later on). The condition $\alpha$ defines the assignments that $\hat\A$ 
should accept. For example, $\alpha = \exists x_1\forall x_2$ requires that 
there exists a word $w_1\in S$ (assigned to $x_1$), such that for every word 
$w_2\in S$ (assigned to $x_2$), the word that represents $(w_1,w_2)$ is accepted 
by $\hat\A$. The hyperword $S$ is accepted by $\A$ iff $S$ meets these 
conditions. 

We now elaborate on how we represent an assignment $v:X\rightarrow S$ as a word. 
We encode the tuple $(v(x_1),v(x_2),\ldots v(x_k))$ by a word ${\bi w}$ whose 
letters are $k$-tuples in $\alphabet^k$, where the $i$'th 
letter of ${\bi w}$ represents the $k$ $i$'th letters of the words 
$v(x_1),\ldots ,v(x_k)$ (in case that the words are not of equal length, we ``pad'' 
the end of the word with $\#$ signs). 
For example, the assignment $v(x_1)=aa,v(x_2)=abb$, represented by the tuple $(aa,abb)$, is encoded by the word 
$ (a,a)(a,b)(\#,b)$.
We later refer to ${\bi w}$ as the {\em zipping} of $v$. Once again, notice that due to the indexing of the word variables, the variables do not explicitly appear in ${\bi w}$.   

%We consider two types of underlying word automata: over finite words and over infinite words. In the former case, the underlying automaton $\hat\A$ is an NFA. In the latter case, $\hat\A$ can be any type of automaton over infinite words. Here, we consider B{\"u}chi word automata. 

We now turn to formally define  hyperautomata.
%of both types. 

\input{NFH}
%\input{NBH}

