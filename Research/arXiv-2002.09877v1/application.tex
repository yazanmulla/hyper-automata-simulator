\section{Hyperregular Expressions and Application in Security}
\label{sec:hre}

Given an NFH $\A$, the language of its underlying NFA $\hat\A$ can be expressed as a regular expression $r$. Augmenting $r$ with the 
quantification condition $\alpha$ of $\A$ constitutes a {\em hyperregular expression} (HRE) $\alpha r$. For example, consider the NFH $\A_1$ in Figure~\ref{fig:nfh_examples}. The HRE of $\A_1$ is:
%
$$
\forall x_1\forall x_2\Big((a, a) \mid (b, b)\Big)^*\Big((\#, b)^* \mid (b, 
\#)^* \Big)
$$
%
We now show the application of HREs in specifying well-known information-flow 
security policies.

{\em Noninteference}~\cite{gm82} requires that commands issued by users holding 
high clearances be removable without affecting observations of users holding 
low clearances:
%
$$
\varphi_{\mathsf{ni}} = \forall x_1\exists x_2(l, l\lambda)^*
$$
%
where $l$ denotes a low state and $l\lambda$ denotes a low state where all high 
commands are replaced by a dummy value $\lambda$.

{\em Observational determinism}~\cite{zm03} requires that if two executions of 
a system start with low-security-equivalent events, then these 
executions should remain low equivalent:
%
$$
\varphi_{\mathsf{od}} = \forall x_1\forall x_2 (l, l)^+ \mid (\bar{l}, 
\bar{l})(\$, \$)^* \mid (l, \bar{l})(\$, \$)^* \mid (\bar{l}, l)(\$, \$)^*
$$
%
where $l$ denotes a low event, $\bar{l} \in \Sigma \setminus \{l\}$, and $\$ 
\in 
\Sigma$. We note that similar policies such as {\em Boudol and Castellaniâ€™s 
noninterference}~\cite{bd02} can be formulated in the same 
fashion.\footnote{This policy states that every two executions that start from 
bisimilar states (in terms of memory low-observability), should remain 
bisimilarly low-observable.}

{\em Generalized noninterference} (GNI)~\cite{m88} allows nondeterminism in 
the low-observable behavior, but requires that low-security outputs may 
not be altered by the injection of high-security inputs:
%
$$
\varphi_{\mathsf{gni}} = \forall x_1\forall x_2\exists x_3 \bigg((h, l, hl) 
\mid (\bar{h}, l, \bar{h}l) \mid (h, \bar{l}, h\bar{l}) \mid (\bar{h}, \bar{l}, 
\bar{h}\bar{l}) \bigg)^*
$$
%
where $h$ denotes the high-security input, $l$ denotes the low-security output, 
$\bar{l} \in \Sigma \setminus\{l\}$, and $\bar{h} \in \Sigma \setminus \{h\}$.

{\em Declassification}~\cite{ss00} relaxes noninterference by allowing leaking 
information when necessary. Some programs need to reveal secret information to 
fulfill functional requirements. For example, a password checker must reveal 
whether the entered password is correct or not:
%
$$
\varphi_{\mathsf{dc}} = \forall x_1\forall x_2 (li,li)(pw, pw)(lo, lo)^+
$$
%
where $li$ denotes low-input state, $pw$ denotes that the password is correct, 
and $lo$ denotes low-output states. We note that for brevity, in the above 
formula, we do not include behaviors where the first two events are not low or 
in the second event, the password is not valid. 

{\em Termination-sensitive noninterference} requires that for two executions 
that
 start from low-observable states, information leaks are not permitted by the termination behavior of the program:
%
$$
\varphi_{\mathsf{tsni}} = \forall x_1\forall x_2 (l, l)(\$, \$)^*(l, l)  \mid 
(\bar{l}, \bar{l})(\$, \$)^* \mid (l, \bar{l})(\$, \$)^* \mid (\bar{l}, l)(\$, 
\$)^*
$$
where $l$ denotes a low state and $\$ \in \Sigma$.

