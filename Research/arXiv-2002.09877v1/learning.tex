\section{Learning NFH}
\label{sec:learning}

In this section, we introduce $\lstar$-based learning algorithms for the fragments $\nfhf$ and 
$\nfhe$. 
We first survey the $\lstar$ algorithm \cite{Angluin87}, and then describe the relevant 
adjustments for our case.

\input{Lstar_summary}

The correctness of the $\lstar$ algorithm follows from the fact that regular languages have a {\em canonical form}, which guarantees a single minimal DFA for a regular language $\cal L$. To enable an $\lstar$-based algorithm for  $\nfhf$ and $\nfhe$, we first define canonical forms for these fragments. 

\input{canonical_forms}


\subsection{Learning $\nfhf$ and $\nfhe$}

We now describe our $\lstar$-based learning algorithms for $\nfhe$ and $\nfhf$.
These algorithms aim to learn an NFH with the canonical form defined in Section~\ref{subsec:canonical.forms} for a target hyperlanguage $\hl$. Figure~\ref{fig:learning_flow} presents the overall flow of the learning algorithms for both fragments. 


In the case of hyperautomata, the membership queries and the counterexamples provided by the teacher consist of hyperwords. Similarly to \cite{fht19}, we assume a teacher that returns a minimal counterexample in terms of size of the hyperword. 

During the procedure, the learner maintains an NFH $\A$ via an observation table for $\hat\A$, over the alphabet $\hat\Sigma  = (\Sigma\cup\{\#\})^k$, where $k$ is initially set to $1$. 
When the number of variables is increased to $k'>k$, the alphabet of $\hat\A$ is extended accordingly to $(\Sigma\cup\{\#\})^{k'}$. 
To this end, we define a function $\uparrow_k^{k'}:(\Sigma\cup\{\#\})^k\rightarrow (\Sigma\cup\{\#\})^{k'}$, which replaces every letter $(\sigma_1,\ldots \sigma_k)$, with $(\sigma_1,\ldots \sigma_k)+(\sigma_k)^{k'-k}$. That is, the last letter is duplicated to create a $k'$-tuple. 
We extend $\uparrow_k^{k'}$ to words: $\uparrow_k^{k'}({\bi w})$ is obtained by replacing every letter $\sigma$ in ${\bi w}$ with $\uparrow_k^{k'}(\sigma)$. 
Notice that, for both fragments, if $\unzip(d\cdot e) \in \hlang{\A}$, then $\unzip(\uparrow_k^{k'}(d\cdot e)) \in \hlang{\A}$. 
Accordingly, when the number of variables is increased, every word ${\bi w}$ in the rows and columns of $T$ is replaced with $\uparrow_k^{k'}({\bi w})$, an action which we denote by $\uparrow_k^{k'}(T)$. 



\subsubsection{Learning $\nfhf$}

In the case of $\nfhf$, when the teacher returns a counterexample $S$, it holds 
that if $|S|> k$, then $S$ must be positive. Indeed, assume by way of 
contradiction that $S$ is negative. Then, for every $k$ words $w_1,\ldots, w_k$ 
in $S$, it holds that $\zip(w_1,\ldots, w_k)\in \lang{\hat\A}$, but $S\notin 
\hl$. Therefore, in an $\nfhf$ $\A'$ for $\hl$, there exists some word of the 
form $w = \zip(w_1,\ldots w_k)$ such that $w_i\in S$ for $1\leq i \leq k$, and 
$w\notin \lang{\hat\A'}$. As a result, $\{w_1,\ldots, w_k\}\notin \hl$. Since 
$\zip(w_1,\ldots, w_k)$ and all its sequences are in $\lang{\hat\A}$, then a 
smaller counterexample is $\{w_1,\ldots, w_k\}$, a contradiction to the 
minimality of $S$. 

In fact, if $|S|>k$, then it must be that $|S| = k+1$. Indeed, since $S$ is a 
positive counterexample, and $\A$ accepts all representations of subsets of size 
$k$ of $S$ (otherwise the teacher would return a counterexample of size $k$), 
then there exists a subset $S'\subseteq S$ of size $k+1$ that should be 
represented, but is not. Therefore, $S'$ is a counterexample of size $k+1$.

When a counterexample $S$ of size $k+1$ is returned, the learner updates $k\leftarrow k+1$, updates $T$ to $\uparrow_k^{k+1}(T)$, arbitrarily selects a permutation $p$ of the words in $S$, and adds  $\zip(p)$ and all its suffixes to $E$.
In addition, it updates $D\cdot\hat\Sigma$ in accordance with the new updated $\hat\Sigma$, and fills in the missing entries.  

When $|S| \leq k$, then the counterexample is either positive or negative.
If $S$ is positive, then there exists some permutation $p$ of the words in $S$ such that $\A$ does not accept $\zip(p)$ (a permutation and not a proper sequence, or there would be a smaller counterexample). The learner finds such a permutation $p$, and adds $\zip(p)$ and all its suffixes to $E$. Notice that $\zip(p)$ does not already appear in $T$, since a membership query would have returned ``yes'', and so $\hat\A$ would have accepted $\zip(p)$.

if $S$ is negative, then $\A$ accepts all sequences of length $k$ of words in $S$, though it should not.
Then there exists a permutation $p$ of the words in $S$ that does not appear in $T$, and which $\A$ accepts. The learner then finds such a permutation $p$ and adds $\zip(p)$ and all its suffixes to $E$.

If $p$ is a permutation of the words in $S$, and $S$ is a negative counterexample, then $\zip(p)$ should not be in $\lang{\hat\A}$ due to any other hyperword, and if $S$ is a positive counterexample, then it should be in $\lang{\hat\A}$ for every $S'$ such that $S\subseteq S'$. Therefore, the above actions by the learner are valid.  

When an equivalence query succeeds, then $\A$ is indeed an $\nfhf$ for $\hl$. 
However, $\A$ is not necessarily sequence-complete, as $\hat\A$ may accept a 
word ${\bi w} = \zip(w_1,\ldots, w_k)$ but not all of its sequences. This check 
can be performed by the learner directly on $\hat\A$. 
Notice that ${\bi w}$ does not occur in $T$, since a membership query on ${\bi w}$ would return ``no''. 
Once it is verified that $\A$ is not sequence-complete, the counterexample ${\bi w}$ (and all its suffixes) are added to $E$, and the procedure returns to the learning loop.
 
As we have explained above, variables are added only when necessary, and so the output $\A$ is indeed an NFH for $\hl$ with minimally many variables. 
The correctness of $\lstar$ and the minimality of the counterexamples returned by the teacher guarantee that for each $k'\leq k$, the run learns a minimal deterministic $\hat\A$ for hyperwords in $\hl$ that are represented by $k'$ variables. Therefore, a smaller $\hat\A'$ for $\hl$ does not exist, as restricting $\hat\A'$ to the first $k'$ letters in each $k$-tuple would produce a smaller underlying automaton for $k'$ variables, a contradiction. 

\begin{figure}[ht]
%\hrulefill
    \begin{center}
        \includegraphics[scale=0.5]{figures/learning_nfhf.pdf}
    \end{center}
    \caption{The first stages of learning $\hlang{\A_3}$ of Figure~\ref{fig:nfh_examples}.}
    \label{fig:learning_nfhf}
%    \hrulefill
\end{figure}

\begin{example}
Figure~\ref{fig:learning_nfhf} displays the first two stages of learning $\hlang{\A_3}$ of Figure~\ref{fig:ordered}.
$T_0$ displays the initial table, with $D=E = \{\epsilon\}$, and $\hat\Sigma = \{a,b,\#\}$. since $\{a\}, \{b\}$, and $\{\epsilon\}$ are all in $\hlang{\A_3}$, the initial candidate NFH $\A$ includes a single variable, and, following the answers to the membership queries, a single accepting state.

Since $\hlang{\A_3}$ includes all hyperwords of size $1$, which are now accepted by $\A$, the smallest counterexample the teacher returns is of size $2$, which, in the example, is $\{a,b\}$. Table $T_1$ is then obtained from $T_0$ by applying $\uparrow_1^2$, updating the alphabet $\hat\Sigma$ to $\{a,b,\#\}^2$, and updating $D\cdot\hat\Sigma$ accordingly. $T_1$ is filled by submitting membership queries. For example, for $(b,a)\in D\cdot\hat\Sigma$ and $(a,b)\in E$, the learner submits a membership query for $\{ba, ab\}$, to which the teacher answers ``no''.
\end{example}

\subsubsection{Learning $\nfhe$}

The learning process for $\nfhe$ is similar to the one for $\nfhf$. We briefly describe the differences. 


As in $\nfhf$, relying on the minimality of the counterexamples returned by the teacher guarantees that when a counterexample $S$ such that $|S|>k$ is returned, it is a positive counterexample. 
Indeed, assume by way of contradiction that $S$ is a negative counterexample of 
size $k'$. Since $\hat\A$ accepts $S$, there exists a word $\zip(w_1,\ldots, 
w_k)$ in $\lang{\hat\A}$ such that $\{w_1,\ldots, w_k\}\in S$. According to the 
semantics of $\exists$, if $\zip(w_1,w_2,\ldots, w_k)\in\lang{\hat\A}$ then 
$S\in\hlang\A$. Since $S\notin\hl$, we have that $\{w_1,\ldots, w_k\}$ is a 
smaller counterexample, a contradiction. 

Therefore, when the teacher returns a counterexample $S$ of size $k'>k$, the alphabet $\hat\Sigma$ is extended to $(\Sigma\cup\{\#\})^{k'}$, and the table $T$ is updated by $\uparrow_{k}^{k'}$, as is done for $\nfhf$.

If $|S|\leq k$, then $S$ may be either positive or negative. If $S$ is negative, then there exists some permutation of $S$ that is accepted by $\hat\A$. However, no such permutation is in $T$, as a membership query would have returned ``no''. Similarly, if $S$ is positive, then there exists no permutation of $S$ that $\hat\A$ accepts. In both cases, the learner chooses a permutation of $S$ and adds it, and all its suffixes, to $E$. 

As in the case of $\nfhf$, the success of an equivalence query does not necessarily imply that $\A$ is permutation-complete. 
If $\A$ is not permutation-complete, the learner finds a word ${\bi w}$ that is a permutation of ${\bi w}'$ such that ${\bi w}'\in\lang{\hat\A}$ but ${\bi w}\notin\lang{\hat\A}$, and adds ${\bi w}$ as a counterexample to $E$. 
The procedure then returns to the learning loop.



\input{figures/learning_flow.tex}

