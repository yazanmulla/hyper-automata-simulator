\section{Introduction}

Hyperproperties~\cite{cs10} generalize the traditional trace 
properties~\cite{as85} to {\em system properties}, i.e., a set of sets of 
traces. Put it another way, a hyperproperty prescribes how the system should 
behave in its entirety and not just based on its individual executions. 
Hyperproperties have been shown to be a powerful tool for expressing and
reasoning about information-flow security policies~\cite{cs10} and important 
properties of cyber-physical systems~\cite{wzbp19} such as sensitivity and 
robustness, as well as consistency conditions in distributed computing such as
linearizability~\cite{bss18}. 

Automata theory has been in the forefront of developing techniques for 
specification and verification of computing systems. For instance, in the
automata-theoretic approach to verification~\cite{vw86,VW94}, the model-checking 
problem is reduced to checking the nonemptiness of the product automaton of the 
model and the complement of the specification. In the industry and other 
disciplines (e.g., control theory), automata are an appealing choice for 
modeling the behavior of a system. Unfortunately, we currently lack a deep 
understanding about the relation between hyperproperties and automata theory. 
To our knowledge, work in this area is limited to ~\cite{fht19}, in which 
the authors develop an automata representation for the class of regular 
$k$-safety hyperproperties. These are hyperproperties where execution traces 
are only universally quantified and their behaviors are non-refutable. They 
introduce the notion of a {\em $k$ bad-prefix automaton} -- a finite-word automaton  
that recognizes sets of $k$ bad  prefixes as finite words. Based on this 
representation, they present a learning algorithm for $k$-safety 
hyperproperties. In~\cite{frs15}, the authors offer a model-checking 
algorithm for hyperCTL$^*$~\cite{cfkmrs14}, which constructs an alternating  
B{\"u}chi automaton that has both the formula and the Kripke structure 
``built-in''. These approaches translate a hyperproperty-related problem to word 
automata.

We generalize the idea in \cite{fht19} to a broader view of an automata-based 
representation of hyperproperties, and introduce {\em hyperautomata} for {\em 
hyperlanguages}, which are languages whose elements are sets of {\em finite} 
words, which we call {\em hyperwords}. In this paper, we propose {\em 
nondeterministic finite-word hyperautomata} (NFH). An NFH runs on {\em 
hyperwords} that contain finite words, by using quantified {\em word variables} 
that range over the words in a hyperword, and a nondeterministic finite-word 
automaton (NFA) that runs on the set of words that are assigned to the 
variables. We demonstrate the idea with two examples.

\begin{example}

Consider the NFH $\A_1$ in Figure~\ref{fig:nfh_examples} (left), whose alphabet 
is $\Sigma = \{a,b\}$, over two word variables $x_1$ and $x_2$. The NFH $\A_1$ contains an underlying standard NFA,
whose alphabet comprises pairs over $\Sigma$, i.e., elements of $\Sigma^2$, in which the first letter represents the letters of the word 
assigned to $x_1$, and dually for the second letter and $x_2$.
%
The underlying NFA of $\A_1$ requires that (1) these two words agree on their 
$a$ (and, consequently, on their $b$) positions, and (2) once one of the words has ended 
(denoted by $\#$), the other must only contain $b$ letters. Since the 
{\em quantification condition} of $\A_1$ is $\forall x_1 \forall x_2$, in a hyperword $S$ that is accepted by $\A_1$, every two words agree on their $a$ positions. As a result, all the words in $S$ must agree on their $a$ 
positions. The hyperlanguage of $\A_1$ is then all hyperwords in which all 
words agree on their $a$ positions. 

\end{example}

\begin{example}
Next, consider the NFH $\A_2$ in Figure~\ref{fig:nfh_examples} (right), over 
the alphabet $\alphabet = \{a\}$, and two word variables $x_1$ and $x_2$. The 
underlying NFA of $\A_2$ accepts the two words assigned to $x_1$ and $x_2$ 
iff the word assigned to $x_2$ is longer than the word assigned to $x_1$. Since 
the quantification condition of $\A_2$ is $\forall x_1 \exists x_2$, we have 
that $\A_2$ requires that for every word in a hyperword $S$ accepted by $\A_2$, 
there exists a longer word in $S$. This holds iff $S$ contains infinitely many 
words. Therefore, the hyperlanguage of $\A_2$ is the set of all infinite 
hyperwords over $\{a\}$. 

\end{example}

\begin{figure}[ht]
\centering
\scalebox{.8}{
        \includegraphics[scale=0.5]{figures/examples.pdf}
    }
    \caption{The NFH $\A_1$ (left) and $\A_2$ (right).}
    \label{fig:nfh_examples}
%    \vspace{-4mm}
\end{figure}

We call the hyperlanguages accepted by NFH {\em regular hyperlanguages}.
A regular hyperlanguage $\hl$ can also be expressed by the regular expression 
for the language of the underlying NFA of an NFH $\A$ for $\hl$, augmented with 
the quantification condition of $\A$. We call such an expression a {\em 
hyperregular expression} (HRE). We demonstrate the ability of HREs to express 
important information-flow security policies such as different variations of 
{\em noninteference}~\cite{gm82} and {\em observational 
determinism}~\cite{zm03}.
 
We proceed to conduct a comprehensive study of properties of NFH  (see 
Table~\ref{tab:results}). In particular, we show that NFH are {\em closed} 
under union, intersection, and complementation. We also prove that the 
{\em nonemptiness} 
problem is in general undecidable for NFH. However, for the alternation-free 
fragments (which only allow one type of quantifier), as well as for the 
$\exists\forall$ fragment (in which the quantification condition is limited to a 
sequence of $\exists$ quantifiers followed by a sequence of $\forall$ 
quantifiers), nonemptiness is decidable. %While we focus on the case of finite 
%words, hyperautomata can be naturally lifted to handle infinite words, with 
%similar complexity results.
These results are in line with the results on satisfiability of 
HyperLTL~\cite{fh16}. We also study the {\em membership} and {\em inclusion} 
problems. These results are aligned with the complexity of HyperLTL model 
checking for tree-shaped and general Kripke structures~\cite{bf18}. This shows 
that, surprisingly, the complexity results in~\cite{fh16,bf18} mainly stem from 
the nature of quantification over finite words and depend on neither the full 
power of the temporal operators nor the infinite nature of HyperLTL semantics.

Finally, we introduce learning algorithms for the alternation-free fragments 
of NFH. Our algorithms are based on Angluin's $\lstar$ algorithm 
\cite{Angluin87} for regular languages, and are inspired by~\cite{fht19}, where the authors describe a learning algorithm that is tailored to learn a $k$-bad prefix NFA for a $k$-safety formula. In fact, the algorithm there can be viewed of as a special case of learning a hyperlanguage in the $\exists$-fragment of NFH. 

In a learning algorithm, a {\em learner} aims to construct an automaton for an unknown target language $\cal L$, by means of querying a {\em teacher}, who knows $\cal L$. The learner asks two types of queries: {\em membership queries} (``is the word $w$ in $\cal L$?'') and {\em equivalence queries} (``is $A$ an automaton for $\cal L$?''). In case of a failed equivalence query, the teacher returns a counterexample word on which $A$ and $\cal L$ differ.  
The learning algorithm describes how the learner uses the answers it gets from the teacher to construct its candidate automaton. 

In the case of NFH, the membership queries, as well as the counterexamples, are hyperwords. The number of variables is unknown in advance, and is also part of the learning goal. 
We first define canonical forms for the alternation-free fragments of NFH, which is essential for this type of learning algorithm.
Then, we proceed to describe the learning algorithms for both fragments. 

\input{table}  

\noindent {\em Organization.} \ The rest of the paper is organized as follows. 
Preliminary concepts are presented in Section~\ref{sec:prelim}. We introduce 
the notion of NFH and HRE in Sections~\ref{sec:ha} and~\ref{sec:hre}, while 
their properties are studied in Section~\ref{sec:nfh_properties}. We propose 
our learning algorithm in Section~\ref{sec:learning}. Finally, we make 
concluding remarks and discuss future work in Section~\ref{sec:concl}. 
Detailed proofs appear in the appendix.