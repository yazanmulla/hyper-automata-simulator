\subsection{Angluin's $\lstar$ Algorithm}

$\lstar$ consists of two entities: a {\em learner}, who wishes to learn a DFA $A$ for an unknown (regular) language $\cal L$, and a {\em teacher}, who knows $\cal L$.
During the learning process, the learner asks the teacher two types of queries: {\em membership queries} (``is the word $w$ in $\cal L$?'') and {\em equivalence queries} (``is $A$ a DFA for $\cal L$?'').

The learner maintains $A$ in the form of an {\em observation table} $T$ of truth values, whose rows $D, D\cdot\Sigma$ and columns $E$ are sets of words over $\Sigma$, where $D$ is prefix-closed, and $E$ is suffix-closed. Initially, $D = E = \{\epsilon\}$. 
For a row $d$ and a column $e$, the entry for $T(d,e)$ is $\true$ iff $d\cdot e \in{\cal L}$. The entries are filled via membership queries.
The vector of truth values for row $d$ is denoted $\row(d)$. Intuitively, the rows in $D$ determine the states of $A$, and the rows in $D\cdot\Sigma$ determine the transitions of $A$: the state $\row(d\cdot\sigma)$ is reached from $\row(d)$ upon reading $\sigma$. 

The learner updates $T$ until it is {\em closed}, which, intuitively, ensures a full transition relation and {\em consistent}, which, intuitively, ensures a deterministic transition relation.
If $T$ is not closed or not consistent then more rows or more columns are added to $T$, respectively. 

\stam{
The learner updates the table until it is both {\em closed} and {\em consistent}. The table is closed if for every $d\in D$ and $\sigma\in \Sigma$, there is $d'\in D$ such that $\row(d') = \row(d\cdot\sigma)$. Intuitively, a closed table assures a full transition relation.
The table is consistent if for every $d_1,d_2\in D$ and every $\sigma \in \Sigma$, it holds that if $\row(d_1) = \row(d_2)$, then $\row(d_1\cdot\sigma) = \row(d_2\cdot\sigma)$. Intuitively, a consistent table assures a deterministic transition relation. 

If the table is not closed, then the missing row $d'$ is added to $D$, and $d'\cdot\sigma$ is added to $D\times\Sigma$ for every $\sigma\in \Sigma$. The new entries in $T$ are filled via membership queries. Note that this leaves $D$ prefix-closed.
If the table is inconsistent, then there is $e\in E$ for which $d_1\cdot\sigma\cdot e \neq d_2\cdot\sigma\cdot e$. The word $\sigma\cdot e$ then separates $\row(d_1)$ from $\row(d_2)$, and is added to $E$ (notice that this leaves $E$ suffix-closed). The new table entries are filled accordingly, and now $\row(d_1)\neq \row(d_2)$. 
}

When $T$ is closed and consistent, the learner constructs $A$: The states are the rows of $D$, the initial state is $\row(\epsilon)$, the accepting states are these in which $T(d,\epsilon) = \true$, and the transition relation is as described above. The learner then submits an equivalence query. If the teacher confirms, the algorithm terminates. Otherwise, the teacher returns a counterexample $w\in \lang{A}$ but $w\notin {\cal L}$ (which we call a {\em positive counterexample}), or $w\notin \lang{A}$ but $w\in {\cal L}$ (which we call a {\em negative counterexample}). The learner then adds $w$ and all its suffixes to $E$, and proceeds to construct the next candidate DFA $A$. 

It is shown in \cite{Angluin87} that as long as $A$ is not a DFA for $\cal L$, it has less states than a minimal DFA for $\cal L$. Further, every change in the table adds at least one state to $A$. Therefore, the procedure is guaranteed to terminate successfully with a minimal DFA $A$ for $\cal L$. 