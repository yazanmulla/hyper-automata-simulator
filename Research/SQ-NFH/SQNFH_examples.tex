% \section{Expressiveness: The Composite Word Example}

% To demonstrate that State-Quantified Hyperautomata (SQ-NFH) are strictly more expressive than standard Finite-Word Hyperautomata (NFH), we present a hyperlanguage that requires dynamic variable extension to be verified.

% \subsection{The Hyperlanguage $H_{composite}$}

% Let $\Sigma = \{a\}$. We define the hyperlanguage $H_{composite}$ as the set of all sets $S \subseteq \Sigma^*$ that contain a ``composite word'': a word $w \in S$ that can be formed by concatenating two or more other words from $S$. Formally:
% \[
% S \in H_{composite} \iff \exists w, u_1, u_2, \dots, u_m \in S \text{ such that } m \ge 2 \text{ and } w = u_1 \cdot u_2 \cdots u_m
% \]

% \subsection{Inadequacy of Regular NFH}
% A standard NFH is defined with a fixed number of variables, $k$. To accept $H_{composite}$, the automaton must witness the decomposition of $w$ into its constituent parts $u_i$. 

% Consider the set $S_k = \{ a, a^{k+1} \}$. The only valid composite relation in $S_k$ is $a^{k+1} = \underbrace{a \cdot a \cdots a}_{k+1 \text{ times}}$. To verify this, an automaton requires $k+2$ logical ``slots'': one for the target word $a^{k+1}$ and $k+1$ for the instances of $a$. An NFH with only $k$ variables cannot simultaneously track all necessary components of this relation. Since $k$ is fixed for the automaton but the required decomposition length can be arbitrarily large, no single NFH can accept $H_{composite}$.

% \subsection{SQ-NFH Construction}
% The SQ-NFH can accept $H_{composite}$ using only two variables by dynamically extending the second variable to match the parts against the target.

% \begin{definition}[Automaton for $H_{composite}$]
% Let $\mathcal{A} = \langle \Sigma, \{x_1, x_2\}, Q, q_{start}, F, \delta, \exists x_1 \exists x_2, L \rangle$, where:
% \begin{itemize}
%     \item $Q = \{ q_{start}, q_{match}, q_{next}, q_{acc} \}$.
%     \item $F = \{ q_{acc} \}$.
%     \item $L = \{ (q_{next}, 2) \}$. This label forces the extension of variable $x_2$ whenever the state $q_{next}$ is reached.
%     \item $\delta$ is defined to simulate the concatenation check:
%     \begin{enumerate}
%         \item \textbf{Initialization:} 
%         \[ (q_{start}, \epsilon, q_{match}) \]
%         Transition silently to the matching phase.
        
%         \item \textbf{Match Characters:} 
%         \[ (q_{match}, (\sigma, \sigma), q_{match}) \quad \forall \sigma \in \Sigma \]
%         Verify that the character in the target $x_1$ matches the character in the current part $x_2$.
        
%         \item \textbf{Part Finished (Refill):} 
%         \[ (q_{match}, (\sigma, \#), q_{next}) \quad \forall \sigma \in \Sigma \]
%         If variable $x_2$ becomes empty (reads $\#$) but $x_1$ still has data ($\sigma$), transition to $q_{next}$ to trigger an extension.
        
%         \item \textbf{Extension Loop:} 
%         \[ (q_{next}, (\sigma, \sigma), q_{match}) \quad \forall \sigma \in \Sigma \]
%         At $q_{next}$, the label in $L$ forces $x_2$ to be extended with a new word from $S$. We immediately compare the first character of this new word against the character $\sigma$ from $x_1$ that was pending.
        
%         \item \textbf{Acceptance:} 
%         \[ (q_{match}, (\#, \#), q_{acc}) \]
%         If both $x_1$ and $x_2$ become empty simultaneously, the concatenation is valid.
%     \end{enumerate}
% \end{itemize}
% \end{definition}

% This automaton effectively verifies $x_1 = x_2 \cdot x_2' \cdot x_2'' \dots$ for an arbitrary number of extensions, proving that SQ-NFH can capture properties defined by unbounded concatenations.



\section{SQ-NFH for $H_{chain}^{\$}$}

\subsection{Formal Definition}
\begin{definition}[Automaton for $H_{chain}^{\$}$]
Let $\Sigma = \{0, 1, \dots, n, \$\}$. We define the SQ-NFH $\mathcal{A} = \langle \Sigma, X, Q, q_0, F, \delta, \alpha, L \rangle$ as follows:
\begin{itemize}
    \item $X = \{x_1, x_2\}$, $\alpha = \exists x_1 \forall x_2$, $F = \{q_{acc}\}$.
    \item $L = \{ (q, 1) \mid q \in Q_{ext} \}$.
    \item $\delta$ is defined visually below.
\end{itemize}
\end{definition}

\subsection{Automaton Diagram}

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[shorten >=1pt, node distance=2.5cm, on grid, auto, initial text=]
        
        %% NODES
        \node[state, initial] (q0) {$q_0$};
        \node[state] (qstart) [right=of q0] {$q_{start}$};
        \node[state] (qread) [right=of qstart] {$q_{read}$};
        
        % The generic "i" branch
        \node[state] (qendi) [above right=2cm and 2.5cm of qread] {$q_{end,i}$};
        \node[state] (qexti) [right=of qendi] {$q_{ext,i}$};
        \node[state] (qstarti) [right=of qexti] {$q_{start,i}$};
        
        % The exit to Part 2
        \node[state] (qend) [below right=2cm and 2.5cm of qread] {$q_{end}$};
        \node[state] (qbuild) [right=of qend] {$q_{build}$};
        \node[state] (qverify) [right=of qbuild] {$q_{verify}$};
        \node[state, accepting] (qacc) [right=of qverify] {$q_{acc}$};

        %% TRANSITIONS - PART 1 (x1 active)
        \path[->] 
            (q0) edge node {$(\$, \#)$} (qstart)
            (qstart) edge node {$(0, \#)$} (qread)
            (qread) edge [loop above] node {$(j, \#)$} (qread)
            
            % The "i" branch loop
            (qread) edge [bend left] node {$(i, \#)$} (qendi)
            (qendi) edge node {$(\$, \#)$} (qexti)
            (qexti) edge node [align=center] {\small $(\$, \#)$ \\ \textbf{[Ext]}} (qstarti)
            (qstarti) edge [bend right=40] node [swap] {$(i, \#)$} (qread);

        %% TRANSITIONS - PART 2 (x2 active)
        \path[->]
            (qread) edge [bend right] node [swap] {$(n, \#)$} (qend)
            (qend) edge node {$(\$, \#)$} (qbuild)
            
            (qbuild) edge node {$(\#, \$)$} (qverify)
            (qverify) edge [loop above] node {$(\#, j)$} (qverify)
            (qverify) edge node {$(\#, \$)$} (qacc);
            
        %% DECORATION (To show there are multiple branches)
        \node [above=0.5cm of qread] {$\vdots$};
        \node [font=\scriptsize, align=center] at (4, -1) {For all $0 \le i \le n-1$};
        
    \end{tikzpicture}
    \caption{Visual representation of the SQ-NFH. The upper loop represents the dynamic extension phase for $x_1$ (Part 1), verifying the chain links. The bottom path represents the validation phase for $x_2$ (Part 2), ensuring well-formedness.}
    \label{fig:sqnfh}
\end{figure}
